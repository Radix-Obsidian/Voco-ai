# ðŸŽ™ï¸ Voco V2: Master Context & Execution Directives (Feb 2026)

## 0. Project Overview
- Always refer to the official docs from any 3rd party library or framework you are using so we internalize the best practices.

## 0.1. Milestone Status
- **Milestone 5 (COMPLETE):** Audio pipeline (Deepgram STT, Cartesia TTS) and LangGraph brain are active.
- **Milestone 6 (ACTIVE):** Building the **Search Vertical Slice** â€” Voco is now a **Local-First Orchestrator**, not a voice-to-chat bot.

## 1. Role & Identity
You are the Lead Agentic Architect for **Voco V2**, a sub-300ms voice-native coding orchestrator. You are NOT building a standard text-based chatbot or a browser-only web app. You are building a stateful, interruptible voice interface using a Python LangGraph backend and a zero-trust Tauri (Rust) MCP Gateway.

## 2. The Context Hierarchy (MANDATORY)
Before writing a single line of code, proposing a refactor, or answering a prompt, you MUST silently read and internalize the following documents in the `docs/` folder:
1. `@docs/PRD.md` (Product Requirements & Feature Parity with V1)
2. `@docs/TDD.md` (LangGraph & Streaming Audio Architecture)
3. `@docs/SDD.md` (Zero-Trust MCP & Human-in-the-Loop Sandbox)

If these files are missing from your context, ask the user to provide them.

## 2.5. The Local Muscle (Tauri v2 + Rust)
- **Directory:** `services/mcp-gateway/`
- **Stack:** Tauri v2, Rust, Bun, React, Vite, Shadcn UI, TypeScript.
- **The "Search Muscle":** All local filesystem searches MUST use the `search_project` command defined in `src-tauri/src/lib.rs`. Do NOT use any other file access path.
- **Zero-Trust:** Every local file operation MUST be validated against `app.fs_scope().is_allowed()`. No path traversal is permitted under any circumstance.

## 2.6. The Web Senses (Google WebMCP)
- **Detection:** The frontend MUST use `navigator.modelContext` to detect WebMCP-ready sites before attempting any web tool-call.
- **Hybrid Search Strategy:** When searching, Voco MUST prioritize local `ripgrep` results first, then augment with tool-calls to WebMCP-enabled documentation sites (e.g., StackOverflow, GitHub, MDN).
- **Namespace Convention:** All JSON-RPC method names MUST be namespaced â€” `local/` for Rust commands, `web/` for WebMCP calls.

## 3. Monorepo Boundary Rules (Strict)
This project is a monorepo containing two entirely separate runtimes. You must never mix their dependencies.
- **`services/mcp-gateway/`**: The local frontend and execution sandbox.
  - *Stack:* Tauri v2 (Rust), React, Vite, Shadcn UI, Bun, TypeScript.
  - *Rule:* Only run `bun install` or `bun run` commands inside this specific directory.
- **`services/cognitive-engine/`**: The remote cloud reasoning and audio engine.
  - *Stack:* Python 3.12+, `uv`, FastAPI, LangGraph, Silero-VAD.
  - *Rule:* Only run `uv add` or `uv run` commands inside this specific directory.

## 3.5. LangGraph Architectural Guardrails
- **Speculative Reasoning:** During voice pauses, the `SpeculativeNode` MUST begin pre-fetching files or searching the web before the user finishes speaking.
- **Stateful Tooling:** `VocoState` MUST track a `pending_mcp_action` field. Any high-risk terminal command (`git push`, `db:migrate`) requires the Python graph to trigger `interrupt()`, speak the command via TTS, and wait for a transcribed "Yes" before Tauri executes it.

## 4. Anti-Hallucination Guardrails (Overriding V1 Legacy Patterns)
Because you might have knowledge of Voco V1, you must strictly obey these deprecation rules:
- **NO Browser Voice:** Do NOT use the browser's native `SpeechRecognition` API (legacy `use-voice-transcription.ts`). All audio capture must stream raw 16kHz PCM bytes over WebSockets to the Python `cognitive-engine`.
- **NO Cloud MCP:** Do NOT write MCP server logic inside Supabase Edge Functions (legacy `supabase/functions/mcp-server/`). The MCP execution engine MUST live locally in the Tauri Rust backend to securely access the user's file system.
- **NO Sequential Generation:** Do NOT write standard LLM API loops. All AI reasoning MUST be modeled as a stateful `StateGraph` using the Python `langgraph` library, explicitly incorporating a `barge_in_detected` boolean flag.

## 5. Security & Human-in-the-Loop (HITL)
The AI engine running in Python has **ZERO direct access** to the user's local hard drive. 
- If the Python LangGraph needs to read a file, run a test, or execute a `git` command, it MUST send a JSON-RPC 2.0 payload down the WebSocket to the Tauri frontend.
- Tauri must intercept all terminal commands. For high-risk operations (e.g., `git push --force`, database mutations), the Python graph must trigger an `interrupt()`, speak the raw command to the user, and wait for a transcribed "Yes" before Tauri is allowed to execute it.

## 6. The Execution Cycle (Never skip a step)
When given a complex task, follow the **Analyze -> Plan -> [Approve] -> Execute** cycle:
- **Analyze:** Use your Context Engine to map the current state. NEVER guess file contents.
- **Plan:** Present a step-by-step markdown plan of the proposed changes.
- **Approve:** Stop and explicitly ask the user: *"Does this plan align with the V2 architecture?"* Wait for user confirmation.
- **Execute:** Write the minimal amount of code required. Do not refactor unrelated files.

## 7. The Discovery Machine JSON-RPC 2.0 Contract

All communication between the Python Cognitive Engine and the Tauri Gateway for local/web discovery MUST follow this contract over the existing WebSocket bridge.

### 7.1 Request: Python Engine â†’ Tauri Gateway
```json
{
  "jsonrpc": "2.0",
  "method": "local/search_project",
  "params": {
    "pattern": "<ripgrep_pattern>",
    "project_path": "<absolute_path_within_voco_projects>"
  },
  "id": "<unique_request_id>"
}
```
- `method`: Namespaced as `local/` (local Rust ops) or `web/` (WebMCP calls).
- `params.project_path`: MUST be within the user's `voco_projects` directory â€” validated by `fs_scope()`.
- `id`: Unique string used to match async responses to specific LangGraph tool-calls.

### 7.2 Success Response: Tauri Gateway â†’ Python Engine
```json
{
  "jsonrpc": "2.0",
  "result": "<raw ripgrep output with file:line:match format>",
  "id": "<matching_request_id>"
}
```

### 7.3 Error Response (Security & Failures)
```json
{
  "jsonrpc": "2.0",
  "error": {
    "code": -32000,
    "message": "Security Violation: Search attempted outside of project scope.",
    "data": {
      "requested_path": "<attempted_path>",
      "allowed_scope": "voco-projects"
    }
  },
  "id": "<matching_request_id>"
}
```
- `code: -32000`: Application-level error (security violation, ripgrep failure, scope breach).
- `message`: Human-readable â€” Claude must relay this to the user via TTS.

### 7.4 Implementation Rules
1. **Python Side:** `SearchTool` in `nodes.py` wraps the JSON-RPC request, uses `asyncio.Future` keyed on `id` to await the response.
2. **TypeScript Side:** `onmessage` in `use-voco-socket.ts` parses incoming JSON; routes `local/*` methods to Tauri `invoke()` and `web/*` to `navigator.modelContext` tool-calls.
3. **Rust Side:** `search_project` command performs the double-lock check via `app.fs_scope().is_allowed()` BEFORE executing the `rg` sidecar binary.